<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Simon Says</title>
<script src="modernizr.js"></script>
<script type="text/javascript">
/*** DEBUG ***/
const DEBUG_SIMON = true;
const DEBUG_STATE = true;
const DEBUG_MOUSE = false;
const DEBUG_PLAYER = true;

window.addEventListener('load', eventWindowLoaded, false);

function eventWindowLoaded() {
	canvasApp();
}

function canvasSupport() {
  	return Modernizr.canvas;
}

function canvasApp() {

	if (!canvasSupport()) {
			 return;
  	} else {
	    var theCanvas = document.getElementById('canvas');
	    var context = theCanvas.getContext('2d');
	}
		
	// Application event listeners	
	theCanvas.addEventListener("mouseup",eventMouseUp, false);		

	// Application states
	const STATE_RESET = 0;
	const STATE_SIMON_WAIT = 10;
	const STATE_SIMON_TURN = 20;
	const STATE_PLAYER_TURN = 30;
	const STATE_PLAYER_WAIT = 40;
	const STATE_GAME_OVER = 50;
	
	// Colors
	const RED = 5;
	const YELLOW = 15;
	const GREEN = 25;
	const BLUE = 35;
	
	// Game variables
	var gameState = STATE_SIMON_TURN;
	var mouseX = 0;
	var mouseY = 0;
	var simonColors = new Array();
	var colorIndex = -1;
	var playerColors = new Array();
	var highlightWaitTimer = 20;
	var offWaitTimer = 5;
	
	function resetGame() {
		simonColors = new Array();
		colorIndex = -1;
		gameState = STATE_SIMON_TURN;
	}
	
	// Implements a pause between displaying picks of the same color so that the player
	// can distinguish that there are multiple picks.
	function wait() {
		if (offWaitTimer <= 0) {
			offWaitTimer = 5;
			//drawBox();
			//drawColors(true);
			gameState = STATE_SIMON_TURN;
		}
		else {
			--offWaitTimer;
			drawBox();
			drawColors(true);
		}
	}

	// Generates a random color and pushes it to simonColors then regurgitates the sequence
	// by controlling colorIndex and calling drawColors().
	function simonTurn() {
		// Increment colorIndex if the current color has been displayed for long enough.
		// CONSIDER PUTTING INTO ANOTHER FUNCTION (e.g. highlightWait()).
		if (highlightWaitTimer <= 0) {
			highlightWaitTimer = 20;
			++colorIndex;
			/*if (simonColors[colorIndex] == simonColors[colorIndex-1])
				gameState = STATE_SIMON_WAIT;
			*/
		} 
		else
			--highlightWaitTimer;
		
		// If this is Simon's first turn (e.g. colorIndex < 0), push a random color to simonColors.
		// Otherwise check to see if we have already displayed all of simonColors already, push a
		// random color to simonColors if we have for the next turn, and set colorIndex to 0 for 
		// the player's turn.
		if (colorIndex < 0) 
			simonColors.push(randomColor());
		else if (colorIndex-1 >= simonColors.length) {
			simonColors.push(randomColor());
			colorIndex = 0;
			resetMouse();
			playerColors = new Array();
			gameState = STATE_PLAYER_WAIT;
		}
		
		/*** DEBUG ***/
		if (DEBUG_SIMON) {
			console.log("colorIndex: "+colorIndex);
			console.log("simonColors[colorIndex]: "+simonColors[colorIndex]);
			console.log("simonColors: "+simonColors);
		}
		
		drawBox();
		drawColors();
	}
	
	
	function playerTurn() {
		playerColors.push(getColorPicked());
		
		/*** DEBUG ***/
		if (DEBUG_PLAYER) {
			console.log("colorIndex: "+colorIndex);
			console.log("playerColors[colorIndex]: "+playerColors[colorIndex]);
			console.log("simonColors[colorIndex]: "+simonColors[colorIndex]);
			console.log("playerColors: "+playerColors);
		}
		
		if (playerColors[colorIndex] != simonColors[colorIndex])
			gameState = STATE_GAME_OVER;
		else if (playerColors.length >= simonColors.length)
			gameState = STATE_SIMON_TURN;
		else {
			++colorIndex;
			resetMouse();
			gameState = STATE_PLAYER_WAIT;
		}
	}

	// Sets mouseX and mouseY to (-1,-1) to simplify hit testing.
	// Should be called before switching to STATE_PLAYER_WAIT
	function resetMouse() {
		mouseX = -1;
		mouseY = -1;
	}
	
	// Waits for mouse clicks on the canvas.
	function waitForInput() {
		if (mouseX >= 0 && mouseY >= 0) {
			gameState = STATE_PLAYER_TURN;
		} 
	}
	
	function getColorPicked() {
		var colorPicked = RED;
		if (mouseX > theCanvas.width/2 && mouseY < theCanvas.height/2)
			colorPicked = BLUE;
		else if (mouseX < theCanvas.width/2 && mouseY > theCanvas.height/2)
			colorPicked = GREEN;
		else if (mouseX > theCanvas.width/2 && mouseY > theCanvas.height/2)
			colorPicked = YELLOW;
		return colorPicked;
	}
	
	function gameOver() {
		context.fillStyle = '#000000';
		context.font = "20px Verdana";
		var text = "GAME OVER";
		context.fillText(text, 200,200);
	}
	
	function drawBox() {
		// Box
		context.fillStyle = '#000000';
		context.fillRect(0,0,theCanvas.width,theCanvas.height);
		
	}
	
	// drawColors determines which color to highlight and draws the rest a darker shade. 
	// If called as drawColors(true) no colors will be highlighted.
	function drawColors(off) {
		off = typeof off !== 'undefined' ? off : false; // Default off to false.
		
		var tempRed = '#B20000';
		var tempYellow = '#B2B200';
		var tempGreen = '#00B200';
		var tempBlue = '#0000B2';
		
		if (!off) {
			var tempColor = simonColors[colorIndex];
			switch (tempColor) {
			case RED:
				tempRed = '#FF0000';
				break;
			case YELLOW:
				tempYellow = '#FFFF00';
				break;
			case GREEN:
				tempGreen = '#00FF00';
				break;
			case BLUE:
				tempBlue = '#0000FF';
				break;
			}
		}  
		
		context.fillStyle = tempRed; // Red
		context.fillRect(0,0,theCanvas.width/2,theCanvas.height/2);
		context.fillStyle = tempYellow; // Yellow
		context.fillRect(theCanvas.width/2,theCanvas.height/2,theCanvas.width/2,theCanvas.height/2);
		context.fillStyle = tempGreen; // Green
		context.fillRect(0,theCanvas.height/2,theCanvas.width/2,theCanvas.height/2);
		context.fillStyle = tempBlue; // Blue
		context.fillRect(theCanvas.width/2,0,theCanvas.width/2,theCanvas.height/2);
	}
	
	// Randomly generates and returns a color.
	function randomColor() {
		var color = RED;
		var randNum = Math.floor(Math.random()*10)%4;
		switch(randNum) {
		case 0:
			color = YELLOW;
			break;
		case 1:
			color = GREEN;
			break;
		case 2:
			color = BLUE;
			break;
		case 3:
			color = RED;
			break;
		}
		return color;
	}

	function eventMouseUp(e) {
	    if(e.offsetX) {
	        mouseX = e.offsetX;
	        mouseY = e.offsetY;
	    } else if (e.layerX) {
	        mouseX = e.layerX;
	        mouseY = e.layerY;
		}
		
		/*** DEBUG ***/
		if (DEBUG_MOUSE)
			console.log("("+mouseX+", "+mouseY+")");
	}

	function run() {
		/*** DEBUG ***/
		if (DEBUG_STATE) {
			switch(gameState) {
			case STATE_PLAYER_WAIT:
				console.log("STATE_PLAYER_WAIT");
				break;
			case STATE_SIMON_WAIT:
				console.log("STATE_SIMON_WAIT");
				break;
			case STATE_RESET:
				console.log("STATE_RESET");
				break;
			case STATE_SIMON_TURN:
				console.log("STATE_SIMON_TURN");
				break;
			case STATE_PLAYER_TURN:
				console.log("STATE_PLAYER_TURN");
				break;
			case STATE_GAME_OVER:
				console.log("STATE_GAME_OVER");
				break;
			}
		}	
		switch(gameState) {
		case STATE_PLAYER_WAIT:
			waitForInput();
			break;
		case STATE_SIMON_WAIT:
			wait();
			break;
		case STATE_RESET:
			resetGame();
			break;
		case STATE_SIMON_TURN:
			simonTurn();
			break;
		case STATE_PLAYER_TURN:
			playerTurn();
			break;
		case STATE_GAME_OVER:
			gameOver();
			break;
		}
	}
		
	// Application Loop
	const FPS = 30;
	var intervalTime = 1000/FPS;
	
	function gameLoop() {
		window.setTimeout(gameLoop, intervalTime);
		run();
	}
	
	gameLoop();
}

</script>
</head>

<body>
</script> 
</head>
<body>
<div style="position: absolute; top: 50px; left: 50px;">
<canvas id="canvas" width="400" height="400">
 Your browser does not support the HTML 5 Canvas. 
</canvas>
</div>
<div id="gameOutput"></div>
</body>
</html>