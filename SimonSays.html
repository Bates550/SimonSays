<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Simon Says</title>
<script src="modernizr.js"></script>
<script type="text/javascript">
/*** DEBUG ***/
const DEBUG_SIMON = false;
const DEBUG_STATE = true;
const DEBUG_MOUSE = false;
const DEBUG_PLAYER = true;

window.addEventListener('load', eventWindowLoaded, false);

function eventWindowLoaded() {
	canvasApp();
}

function canvasSupport() {
  	return Modernizr.canvas;
}

function canvasApp() {

	if (!canvasSupport()) {
			 return;
  	} else {
	    var theCanvas = document.getElementById('canvas');
	    var context = theCanvas.getContext('2d');
	}
		
	// Application event listeners	
	theCanvas.addEventListener("mouseup",eventMouseUp, false);		

	// Application states
	const STATE_RESET = 0;
	const STATE_SIMON_WAIT = 10;
	const STATE_SIMON_PUSH = 20;
	const STATE_SIMON_DISPLAY = 30;
	const STATE_PLAYER_TURN = 40;
	const STATE_PLAYER_WAIT = 50;
	const STATE_GAME_OVER = 60;
	
	// Colors
	const RED = 5;	
	const YELLOW = 15;
	const GREEN = 25;
	const BLUE = 35;
	
	// Game variables
	var gameState = STATE_SIMON_PUSH;
	var mouseX = 0;
	var mouseY = 0;
	var simonColors = new Array();
	var colorIndex = 0;
	var playerColors = new Array();
	var highlightInterval = 20;
	var highlightTimer = highlightInterval;
	var waitInterval = 5;
	var waitTimer = waitInterval;
	
	function resetGame() {
		simonColors = new Array();
		colorIndex = 0;
		gameState = STATE_SIMON_PUSH;
	}
	
	// Implements a pause between displaying picks of the same color so that the player
	// can distinguish that there are multiple picks.
	function simonWait() {
		if (waitTimer <= 0) {
			waitTimer = waitInterval;
			drawBox();
			drawColors(true);
			gameState = STATE_SIMON_DISPLAY;
		}
		else {
			--waitTimer;
			drawBox();
			drawColors(true);
		}
	}

	// Pushes a random color to simonColors
	function simonPush() {
		simonColors.push(getRandColor());
		gameState = STATE_SIMON_DISPLAY;
	}


	// Displays each color in simonColors highlighted for a short period (as determined by
	// highlightInterval).
	function simonDisplay() {
		if (highlightTimer > 0 && colorIndex < simonColors.length) {
			--highlightTimer;
			drawBox();
			drawColors();
		}
		else if (colorIndex < simonColors.length) {
			++colorIndex;
			highlightTimer = highlightInterval;
			gameState = STATE_SIMON_WAIT;
		}
		else {
			resetMouse();
			gameState = STATE_PLAYER_WAIT;
			drawBox();
			drawColors();
			colorIndex = 0;
		}

		//drawBox();
		//drawColors();

		/*** DEBUG ***/
		if (DEBUG_SIMON) {
			console.log("highLightTimer: "+highlightTimer);
			console.log("colorIndex: "+colorIndex);
			console.log("simonColors[colorIndex]: "+simonColors[colorIndex]);
			console.log("simonColors: "+simonColors);
		}
	}

	// Pushes a random color to simonColors, displays each color highlighted for a short period
	// (as determined by highlightInterval), and then changes game state to STATE_PLAYER_WAIT.
/*	function simonTurn() {
		simonColors.push(getRandColor());

		if (highlightTimer > 0) {
			--highlightTimer;
		} 
		else if (colorIndex < simonColors.length) {
			hightlightWaitTimer = highlightInterval;
			++colorIndex;
		}

		drawBox();
		drawColors();
	}
*/
	
	// playerTurn() pushes player's color choice to playerColors and checks it against 
	// the color at simonColors[colorIndex]. If the colors are the same and we have not 
	// reached the end of simonColors, we again wait for player input, and if the colors
	// do not match, it's game over... man.
	function playerTurn() {
		playerColors.push(getColorPicked());

		/*** DEBUG ***/
		if (DEBUG_PLAYER) {
			console.log("colorIndex: "+colorIndex);
			console.log("playerColors[colorIndex]: "+playerColors[colorIndex]);
			console.log("simonColors[colorIndex]: "+simonColors[colorIndex]);
			console.log("playerColors: "+playerColors);
		}

		if (playerColors.length >= simonColors.length && playerColors[colorIndex] == simonColors[colorIndex]) {
			playerColors = new Array();
			colorIndex = 0;
			gameState = STATE_SIMON_PUSH;
		}
		else if (playerColors[colorIndex] == simonColors[colorIndex]) {
			++colorIndex;
			resetMouse();
			gameState = STATE_PLAYER_WAIT;
		}
		else 
			gameState = STATE_GAME_OVER;
	}

	// Sets mouseX and mouseY to (-1,-1) to simplify hit testing.
	// Should be called before switching to STATE_PLAYER_WAIT
	function resetMouse() {
		mouseX = -1;
		mouseY = -1;
	}
	
	// Waits for mouse clicks on the canvas.
	function playerWait() {
		if (mouseX >= 0 && mouseY >= 0) {
			gameState = STATE_PLAYER_TURN;
		} 
	}
	
	function getColorPicked() {
		var colorPicked = RED;
		if (mouseX > theCanvas.width/2 && mouseY < theCanvas.height/2)
			colorPicked = BLUE;
		else if (mouseX < theCanvas.width/2 && mouseY > theCanvas.height/2)
			colorPicked = GREEN;
		else if (mouseX > theCanvas.width/2 && mouseY > theCanvas.height/2)
			colorPicked = YELLOW;
		return colorPicked;
	}
	
	function gameOver() {
		context.fillStyle = '#000000';
		context.font = "20px Verdana";
		var text = "GAME OVER";
		context.fillText(text, 200,200);
	}
	
	function drawBox() {
		// Box
		context.fillStyle = '#000000';
		context.fillRect(0,0,theCanvas.width,theCanvas.height);
		
	}
	
	// drawColors determines which color to highlight and draws the rest a darker shade. 
	// If called as drawColors(true) no colors will be highlighted.
	function drawColors(off) {
		off = typeof off !== 'undefined' ? off : false; // Default off to false.
		
		var tempRed = '#B20000';
		var tempYellow = '#B2B200';
		var tempGreen = '#00B200';
		var tempBlue = '#0000B2';
		
		if (!off) {
			var tempColor = simonColors[colorIndex];
			switch (tempColor) {
			case RED:
				tempRed = '#FF0000';
				break;
			case YELLOW:
				tempYellow = '#FFFF00';
				break;
			case GREEN:
				tempGreen = '#00FF00';
				break;
			case BLUE:
				tempBlue = '#0000FF';
				break;
			}
		}  
		
		context.fillStyle = tempRed; // Red
		context.fillRect(0,0,theCanvas.width/2,theCanvas.height/2);
		context.fillStyle = tempYellow; // Yellow
		context.fillRect(theCanvas.width/2,theCanvas.height/2,theCanvas.width/2,theCanvas.height/2);
		context.fillStyle = tempGreen; // Green
		context.fillRect(0,theCanvas.height/2,theCanvas.width/2,theCanvas.height/2);
		context.fillStyle = tempBlue; // Blue
		context.fillRect(theCanvas.width/2,0,theCanvas.width/2,theCanvas.height/2);
	}
	
	// Randomly generates and returns a color.
	function getRandColor() {
		var color = RED;
		var randNum = Math.floor(Math.random()*10)%4;
		switch(randNum) {
		case 0:
			color = YELLOW;
			break;
		case 1:
			color = GREEN;
			break;
		case 2:
			color = BLUE;
			break;
		case 3:
			color = RED;
			break;
		}
		return color;
	}

	function eventMouseUp(e) {
	    if(e.offsetX) {
	        mouseX = e.offsetX;
	        mouseY = e.offsetY;
	    } else if (e.layerX) {
	        mouseX = e.layerX;
	        mouseY = e.layerY;
		}
		
		/*** DEBUG ***/
		if (DEBUG_MOUSE)
			console.log("("+mouseX+", "+mouseY+")");
	}

	function run() {
		/*** DEBUG ***/
		if (DEBUG_STATE) {
			switch(gameState) {
			case STATE_PLAYER_WAIT:
				console.log("STATE_PLAYER_WAIT");
				break;
			case STATE_SIMON_WAIT:
				console.log("STATE_SIMON_WAIT");
				break;
			case STATE_RESET:
				console.log("STATE_RESET");
				break;
			case STATE_SIMON_PUSH:
				console.log("STATE_SIMON_PUSH");
				break;
			case STATE_SIMON_DISPLAY:
				console.log("STATE_SIMON_DISPLAY");
				break;
			case STATE_PLAYER_TURN:
				console.log("STATE_PLAYER_TURN");
				break;
			case STATE_GAME_OVER:
				console.log("STATE_GAME_OVER");
				break;
			}
		}	
		switch(gameState) {
		case STATE_PLAYER_WAIT:
			playerWait();
			break;
		case STATE_SIMON_WAIT:
			simonWait();
			break;
		case STATE_RESET:
			resetGame();
			break;
		case STATE_SIMON_PUSH:
			simonPush();
			break;
		case STATE_SIMON_DISPLAY:
			simonDisplay();
			break;
		case STATE_PLAYER_TURN:
			playerTurn();
			break;
		case STATE_GAME_OVER:
			gameOver();
			break;
		}
	}
		
	// Application Loop
	const FPS = 30;
	var intervalTime = 1000/FPS;
	
	function gameLoop() {
		window.setTimeout(gameLoop, intervalTime);
		run();
	}
	
	gameLoop();
}

</script>
</head>

<body>
</script> 
</head>
<body>
<div style="position: absolute; top: 50px; left: 50px;">
<canvas id="canvas" width="400" height="400">
 Your browser does not support the HTML 5 Canvas. 
</canvas>
</div>
<div id="gameOutput"></div>
</body>
</html>